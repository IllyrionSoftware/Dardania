=====================
NEW with BRX 17 SDK :
=====================

To improve usability of the C++ OPM API, a number of new virtual functions have been added :

    virtual bool getApplicationName(AcString& name) const
    virtual void beginPropertiesUpdate(const AcDbObjectIdArray& selectionSet) const
    virtual void endPropertiesUpdate() const

'getApplicationName()' allows the OPM management to associate an "application name" with
a particular client extension (for several internal purpose, for display, and more);
it is optional, and not mandatory to ensure proper behaviour.

'beginPropertiesUpdate()' is sent with any change in selection, as very first event, providing
the selectionSet to be processed afterwards;
for the 'NoSelection' mode, the AcDbObjectIdArray is empty.

'endPropertiesUpdate()' signals that the OPM update is complete, no further operations.

These begin + end notifications allow a client application to inspect the selection, and
to prepare internal data structures, lookup entity dependencies and so on.


Besides minor bugfixing + improvements, the C++ OPM API now supports "subentity properties" -
i.e. for edges and faces of AcDb3dSolids, and similar.

    enum AcOpmSubEntityType
    {
        opmNullSubentType   = 0x00,
        opmFaceSubentType   = 0x01,
        opmEdgeSubentType   = 0x02,
        opmVertexSubentType = 0x04,
    };

To support subentities, the property registration by

    AcOpmResult AcOPMExtensionManager::registerEntityExtension(
                                            AcOPMClientExtension* clientExtension,
                                            const AcRxClass* entityClass,
                                            bool supportsDerivedClasses = false,
                                            int subEntityTypes = opmNullSubentType
                                            ) = 0;

has been extended by 'int subEntityTypes = opmNullSubentType' - by default, the registration
applies to main entity only (opmNullSubentType);
'subEntityTypes' can be a combination of any AcOpmSubEntityType enum values.

During registration of client extension, AcOPMExtensionManager will use the new

    virtual bool getPropertyMap(const AcRxClass* entityClass,
                                const AcOpmSubEntityType subentType,
                                AcOPMPropertyArray& properties) const
    {
        return false;
    };

function, if 'subEntityTypes' is not opmNullSubentType;
this new function is called for each AcOpmSubEntityType value specified.

For 'dynamic + per-instance properties', the new function

    virtual bool getDynamicPropertyMap(const AcDbEntity* entity,
                                       const AcOpmSubEntityType subentType,
                                       const AcDbFullSubentPathArray& fspArray,
                                       AcOPMPropertyArray& properties) const
    {
        return false;
    };

is called during selection, specifying all selected 'AcDbFullSubentPath' subentities for the
given AcOpmSubEntityType, for each selected entity (if registered for multiple subentity types,
multiple calls to this function will occure).

Finally, there are also 2 new functions to get & set the property values for subentities :

    virtual bool getPropertyValue(const AcDbEntity* entity,
                                  const AcOpmSubEntityType subentType,
                                  const AcDbFullSubentPathArray& fspArray,
                                  const AcOPMPropertyId propertyId,
                                  const AcString& childName,
                                  AcOPMVariant& value) const
    {
        return false;
    };

    virtual bool setPropertyValue(AcDbEntity* entity,
                                  const AcOpmSubEntityType subentType,
                                  const AcDbFullSubentPathArray& fspArray,
                                  const AcOPMPropertyId propertyId,
                                  const AcString& childName,
                                  const AcOPMVariant& value)
    {
        return false;
    };

which are called for all selected entities, once for each specified subentity type.


Class AcOPMPropertyEntry now has 2 new (non-virtual) functions

    void  setClientData(void* clientData) { m_pClientData = clientData; };
    void* getClientData() const { return m_pClientData; };

to set & get associated "client data" for an extension property - this allows easier management of
properties on client side.

Note :
------
AcOPMExtensionManager now also provides the
    virtual void* getActiveOPMPropertyClientData () const = 0;
to retrieve the "client data" associated with the actual extension property, when called from inside
a callback function.

Alternatively :
---------------
client code can also call AcOPMExtensionManager's
    virtual bool  getActiveOPMPropertyEntry (AcOPMPropertyEntry& activeOPMEntry) = 0;
function, to retrieve the actual extension property, when called from inside a callback function;
this also allows to retrieve the property's "client data".



=====================
NEW with BRX 16 SDK :
=====================

Build environment for applications is now VS 2013 (VC12);
BricsCAD and all libraries are now compiled with VS 2013.

Sample applications have been updated for VS 2013 builds;
the ARX build configurations now target ARX 2016 SDK (using "ARX2016_SDK_PATH" env. variable),
using "v110" platform toolset (VS 2012, VC11).


Other enhancements :
--------------------

1. added a new virtual function to retrieve the active AcOPMPropertyEntry
   (to be called by client applications during any callback)

   virtual bool AcOPMExtensionManager::getActiveOPMPropertyEntry (AcOPMPropertyEntry& activeOPMEntry) = 0;

   added another virtual function to allow client OPM extensions to declare
   particular 'native' properties as read-only;
   automatically called during 'acRegisterEntityExtension()'

   virtual bool getNativePropertiesToDisable (AcOPMNativePropertyArray& disableNativeProps) const

   see "<BRX-SDK>/inc/BrxSpecific/AcOpmExtensions.h" header


2. added a new enum for 'AcOpmDataType' : opmFlagReloadPanelOnModify = 0x1000

this flag can be combined with any other enum of 'AcOpmDataType', to trigger a "Reload of OPM Panel",
after a property value has been changed

=> this allows a particular property, to reload/redisplay the PropertiesPanel, in case that other
   custom properties depend on the changes value, and shall display adjusted values after editing



=================================
New with BRX 15 SDK : C++ OPM API
=================================

BRX V15 provides a new C++ interface for the OPM (PropertiesPanel), which allows to show
categories and properties for native entities and custom entities, and additionally to show
application-specific categories and properties, when no entity is selected ("No Selection"
page in PropertiesPanel).

This new interface is provided by ./BrxSpecific/AcOpmExtension.h header, which is
automatically included by "arxHeaders.h" as well.

The main intention for this new C++ interface is to provide application developers an efficient
way to use the PropertiesPanel for built-in (native) entities, custom entities, and for comman
purpose.
In example, applications using native entities (rather than custom entities) with special
"tags/markes" by XData, ExtensionDictionary or similar references can easily display "custom"
properties for such entities, while "untagged/not-marked" native entities behave normal.

The new API works mainly like a reactor system - a handler object is registered to the OPM
Manager, which then queries the handler object for categories, properties, values etc.
Please have a look at AcOpmExtension.h.

Sample Application :
--------------------
the BRX sample application "<BRX SDK>/samples/brx/brxSample" installed with BricsCAD and BRX SDK
also contains a full-blown sample to manage the C++ OPM extensions - intended to visualise all
provided panel properties, and to demonstrate the logic and handling between OPM Manager and client-side
OPM extensions.

supported Platforms :
---------------------
as the new interface is pure C++ based, it is available on all BricsCAD platforms (Windows, Linux, Mac)


Detailled documentation for the C++ OPM API :
---------------------------------------------
Including the header file "BrxSpecific/AcOpmExtensions.h" is sufficient to get access to the API;
this file is automatically included when using "arxHeaders.h".

OPM Extension Manager :
BRX and BricsCAD provide a singleton "OPM Extension Manager" instance of type 'AcOPMExtensionManager';
the global function
    AcOPMExtensionManager* acOPMExtensionManager();
provides this instance.

The AcOPMExtensionManager provides several functions to register + unregister client-side OPM extensions
of type 'AcOPMClientExtension'; to simplify registration and unregistration, a number of macros are
also provided.

On BRX client side, all OPM extensions are provided via 'AcOPMClientExtension' instances -
the client code has all freedom to use a single or multiple instance(s) of 'AcOPMClientExtension' to
give maximum flexibility.

Each entry to be added to OPM is represented as an instance of type 'AcOPMPropertyEntry', describing
the parameters for the PropertiesPanel entry.

Transfering data values to/from OPM is based on 'AcOPMVariant' instances - a simple + straight "Variant"
like class providing all necessary constructors, get/set functions, assignment and comparison operators.

All these classes are fully implemented in the single header - please take a look for more details.


Some fundamentals :
-------------------
The main idea behind the new C++ OPM API is to provide a reactor-like mechanism, which allows
applications to "register" their desired property entries to the OPM, by providing one or more
"handler" instance(s) (or callbacks) of type 'AcOPMClientExtension' - the handler then registers
the desired properties and is responsible to update the properties to the OPM and to underlying
data and entities.

Proeprty entries can be added for the "Selected Entities" mode of the OPM, and also for the special
"No Selection" mode of the OPM, to allow access to application and/or document/database-specific
settings.

Whenever the OPM needs to update/refresh the properties, the AcOPMExtensionManager queries into
all registered AcOPMClientExtension, to get information about each property :
- the display name of a Category
- the display name ("label") of a property
- the read-only state of a property
- the enabled state of a property
- the optional "predefined strings" (to establish a dropdown list)
- and finally the property value itself

Properties are always identified by their unique ID as described in each AcOPMPropertyEntry;
Child items (if a property has sub-items) are always identified by their registered "key" name.
This means, all queried property and category names are always + only used for visualisation,
never for identifying a (child-)property; this provides elegant translations for the user interface.

Requirement :
the only requirement is, to have all defined properties using a unique integer ID within one
instance of 'AcOPMClientExtension'; in other words, when using multiple 'AcOPMClientExtension',
using same identifiers is perfectly fine.
(background : the AcOPMExtensionManager keeps an internal mapping of those "per-extension-IDs"
to the globally unique property identifier as used inside the OPM).

Some rules :
all the virtual functions (callbacks) of AcOPMClientExtension use a return type "bool", the
default implementations return 'false' - this does NOT mean an error status, but rather signals
a "does-not-apply" status : in such cases, the AcOPMExtensionManager ignores the result values
and uses internal/default/automatic behaviour.


Step-by-Step instructions to add properties to the OPM panel :
--------------------------------------------------------------

1. derive an instance from AcOPMClientExtension for the application
...................................................................
   similar to a reactor, not all provided virtual functions need to be overwritten (the sample does
   so, mainly to show their usage); all virtual callback functions have a default implementation,
   returning 'false' to indicate the result being "not-applicable".

2. registering the AcOPMClientExtension to AcOPMExtensionManager
................................................................

a) for the "selected entities" pages of OPM, use

   acOPMExtensionManager()->registerEntityExtension(AcOPMClientExtension* clientExtension,
                                                    const AcRxClass* entityClass,
                                                    bool supportsDerivedClasses = false)

   (or acRegisterEntityExtension(...) macro function)

   'entityClass' specifies the type of entity you want your 'clientExtension' as a server;
                 if 'supportsDerivedClasses' is given as 'true', then the 'clientExtension'
                 will also get the query callbacks for entities derived from specified class
                 'entityClass'
                 -> this provides flexibility if an application uses multiple custom entities
                    based on same base class; registering for the base-class allows the Extension
                    instance to handle all derived classes then

   returns an AcOpmResult error status to indicate success or failures

   Tip 1:
   ------
   the application can decide on its own, whether to register a dedicated 'clientExtension' for
   each registered entity class, or to use a singleton 'clientExtension' instance to server for
   all registered entity class (or even any mix)


b) for the "No Selection" pages of OPM, use

   acOPMExtensionManager()->registerGeneralExtension(AcOPMClientExtension* clientExtension)

   (or acRegisterGeneralExtension(...) macro function)

   the specified 'clientExtension' will be used as a callback handler, when the OPM switches
   into "No Selection" mode

   returns an AcOpmResult error status to indicate success or failures

   Tip 2:
   ------
   applications can use the same 'clientExtension' as registered for the "Selected Entities" OPM mode,
   but are entirely free to use a dedicated 'clientExtension' for the "No Selection" mode;
   it is even possible to use register multiple 'clientExtension' instances for "No Selection" mode,
   and also use multiple 'clientExtension' instances for the "Selected Entities" mode


3. registering the desired properties to AcOPMExtensionManager
..............................................................

a) for the "selected entities" pages of OPM

   during extension registration by "registerEntityExtension()", the AcOPMExtensionManager queries
   for the properties to be registered by calling :

   clientExtension->getPropertyMap(const AcRxClass* entityClass, AcOPMPropertyArray& properties)

   'entityClass' specifies the entity class for which properties shall be registered
                 (useful especially, if a clientExtension registers for multiple entity classes)

   'properties' an empty array to be filled with AcOPMPropertyEntry instances


b) for the "No Selection" pages of OPM

   during extension registration by "registerGeneralExtension()", the AcOPMExtensionManager queries
   for the properties to be registered by calling :

   clientExtension->getPropertyMap(AcOPMPropertyArray& properties)

   'properties' an empty array to be filled with AcOPMPropertyEntry instances


The 'properties' array keeps copies of AcOPMPropertyEntry instances, to simplify lifetime and
scope handling.


4. adding AcOPMPropertyEntry property entries
.............................................................
There are several constructors provided for AcOPMPropertyEntry, and all data members are public;
the CopyConstructor and assignment operator are available as well.

AcOPMPropertyEntry data members :
---------------------------------

  AcString m_categoryName              // used as 'Label' for category (ignored for built-in categories)
  AcOPMCategoryId m_categoryId         // predefined or client category ID

    -> define the Category to which a property is to be added :
       - there are predefined Categories (see the AcOPMCategoryId predefined values), identified
         by their integer values (always negative); for predefined Categories, the 'm_categoryName'
         can be omitted (empty string)
       - using an application-specific (non-predefined) Category, specify an arbitrary name, an
         'm_categoryId' is optional, best is to omit then, using AcOPMCAT_Nil as value, will be
         automatically get a unique ID assigned
       - if a dedicated Category ID is provided, the application is responsible to provide a unique
         ID (starting with AcOPMCAT_FirstUserCat) for each Category (unique ID qithin extension)
    -> for "No Selection" mode properties, built-in (predefined) Categories can not be used !

  AcString m_propertyName              // property label
  AcOPMPropertyId m_propertyId         // property ID unique within application (built-in properties are ignored)

    -> specifies the 'Name' and 'ID' of the Proeprty to be added :
       - 'Name' is then used as a "key" name for Property identification, a user-friendly name can
         optionally be provided by response to "getPropertyName()"; if no Property name is provided in
         response to "getPropertyName()"; this "key" name is used as label
       - 'ID' is a (per-extension) unique integer identifier starting with AcOPMPROP_FirstUserProp,
         to identify the Property; this value is used for all the extension callbacks

  AcOpmDataType m_propertyType         // data type for property

    -> defines the type of the Proeprty to be added, must be one of the values as defined by
       'AcOpmDataType' enum;
       can be any of the "plain" data types, or a "logical" data type;
       specialties for 'opmTypeRange', 'opmTypePatternType', 'opmTypePatternName', and
       'opmTypeCombo' property types are explained below

  AcStringArray m_predefinedStrings    // array of predefined value strings

    -> if the Proeprty shall use a combobox with predefined values to select, those predefined
       strings can be provided by 'm_predefinedStrings' at registration time (mainly, if that list
       is constant and does not change);
       for "dynamic lists", the extension handler can also provide the list of values by response
       to "getPredefinedStrings()" functions; this requires to use the property type 'opmTypeEnum'
       or 'opmTypeCombo', so that AcOPMExtensionManager knows the property wants to use a combobox
       with predefined values

  bool m_editable                      // false for a read-only property

    -> defines whether the Proeprty is read-only;
       AcOPMExtensionManager will also query this status for each property by "getPropertyReadOnly()"
       at runtime; preset 'm_editable' then allows to ignore or omit "getPropertyReadOnly()"

  bool m_isPerInstance                 // false for a normal property, true for a Per-Instance property

    -> defines whether the Property is "Per Entity Instance";
       if specified as "true", the AcOPMExtensionManager knows that the property can vary for each
       entity instance; has no real impact on behaviour, as AcOPMExtensionManager always completely
       queries all parameters for a Property
       (mainly implemented to provide some logical compatibility for developers, used to the COM OPM
        interface)

  AcOPMPropertyDialogProc m_callbackFunc; // property editor (as callback), if non-NULL

    -> a client-side callback handler for Properties of type 'opmTypeCallback';
       for such Properties, the client extension is responsible for editing the Property value,
       i.e. using the commandline or a dialog, or whatever is prefered by application;
       if specified, the callback editor must be a function of type 'AcOPMPropertyDialogProc'
    -> for some hints, please see below

  AcStringArray m_childNames           // array of property labels for child items
  AcArray<AcOpmDataType> m_childTypes  // array of data types for child items

    -> if the Proeprty wants to use 'Child' items (which is, the Property can be expanded to show
       sub-items, similar how 2d/3d Points are shown in OPM panel), the 'm_childNames' and
       'm_childTypes' arrays hold the names and Property types for the child items;
       the names are used as "key" names, and can be translated as user-interface labels by
       answering the "getPropertyName()" query, if needed



5. overriding + answering the several AcOPMClientExtension callbacks :
......................................................................

There is a simple rule for all the callbacks discussed here :
returning a 'false' status means, the property does not support the query (this is the default
implementation), which causes the AcOPMExtensionManager to apply a default and/or to ignore the
particular query; the specific result is documented for each callback.

bool getPropertyName(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                      const AcString& childName, AcString& name) const

  this function is called to retrieve the 'Name' of an entity, to be shown in the entity types
  combobox of the OPM; provide the user-interface name for the custom entity type (this is not
  called for native entities !) should be returned by the 'name' argument;
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager ignores the returned 'name'
  and uses the DXF entity name, until next query


bool getPropertyDescription(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                            const AcString& childName, AcString& description) const

  this function is called to retrieve a 'description' for the property; this description is actually
  unused by the OPM, except for 1 particular case :
  for the "CheckBox Property", the provided 'description' is used as a label placed at the right
  side of the checkbox;
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager ignores this query, no
  'description' is processed, until next query


bool getPropertyEnabled(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                        const AcString& childName, bool& enabled, bool& hideDisabled) const

  this function is called to retrieve the 'enabled' status for the property;
  if 'enabled' is set to 'false', the property is shown in disabled status;
  if 'hideDisabled' is set to 'true', then the property is even hidden in the OPM;
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager ignores the query, and the
  property is enabled + shown, until next query


bool getPropertyReadOnly(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                     const AcString& childName, bool& readOnly) const

  this function is called to retrieve the 'read-only' status for the property;
  if 'readOnly' is set to 'true', the property is shown in read-only status (this is,
  the value part is dimmed/grayed);
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager ignores the query, and the
  property is read/write-enabled, until next query


bool getPredefinedStrings(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                          const AcString& childName, AcStringArray& predefinedStrings) const

  this function is called for any property using 'opmTypeString', 'opmTypeEnum' and 'opmTypeCombo'
  to query for the 'predefined strings' - those are the entries for a dropdown/combobox;
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager ignores the query, and the
  'predefined strings' as provided by the property registration (if any - otherwise, the property
  continues as a normal string property, until next query)


bool getPropertyValue(const AcDbEntity* entity, AcOPMPropertyId propertyId,
                      const AcString& childName, AcOPMVariant& value) const

  this function is called for to retrieve the *actual* value for the property;
  the 'value' should be assigned a suitable data value; the type of the data depends on the
  property's 'AcOpmDataType' property type;
  please see suitable data types at enum 'AcOpmDataType', as many property types support
  multiple data types (i.e. SymbolTable related properties can use the AcDbObjectId or a string,
  specifying the SymbolTableRecord);
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager hides the property in OPM,
  until the next query for the value returns a valid result


bool setPropertyValue(AcDbEntity* entity, AcOPMPropertyId propertyId,
                      const AcString& childName, const AcOPMVariant& value)

  this function is called when the user has changed the value for a proeprty; the handler should
  update the related data (entity data, internal data etc.);
  'childName' is empty for a main property, otherwise it contains the ("key") name for the child
  property, as defined in property registration;
  if 'false' (not-applicable) is returned, the AcOPMExtensionManager treats the value assignment
  as failing;
  in any case, after assigning a value, the OPM refreshes the property by reading the actual
  property value again, using "getPropertyValue()" (this ensure safe property display)


6. unregistering + removing AcOPMClientExtension instances :
............................................................

The good news first - normally, applications only need to explicitly remove their registered
OPM extensions, when the application supports unloading - in this case, the easiest way is
to call acOPMExtensionManager()->removeExtension() for any registered 'AcOPMClientExtension*'
client extension.

Otherwise, all registered 'AcOPMClientExtension*' client extensions are automatically removed
from OPM during BricsCAD shutdown, so applications will only need to cleanup/delete their
'AcOPMClientExtension*' instances
(background : AcOPMExtensionManager does not use the registered 'AcOPMClientExtension*' instances
directly, but copies all registration data to internal (extended) versions of extensions and
properties).

AcOPMExtensionManager also allows flexible dynamic managment of client extensions and properties :

  bool unregisterEntityExtension(AcOPMClientExtension* clientExtension, const AcRxClass* entityClass)

  -> unregisters an extension from "Entity Selection" mode, for specified entity class;
     especially useful if a particular extension was registered for multiple entity classes
  -> provided macro : acUnregisterEntityExtension()

  bool unregisterGeneralExtension(AcOPMClientExtension* clientExtension)

  -> unregisters an extension from "No Selection" mode
  -> provided macro : acUnregisterGeneralExtension()

  bool removeExtension(AcOPMClientExtension* clientExtension)

  -> unregisters an extension from both Entity Selection"" and "No Selection" mode,
  -> provided macro : acRemoveOPMExtension()


Hints for some specific Property types :
----------------------------------------

For a few property types, a special handling is applied and needs some explanations ...

'opmTypeRange' - always using integer type

  as the get/set functions only transfer a single datum, and a 'range' needs a minimum and maximum
  definition as well, a special logic is used :
  the first  16 bit part of the INT64 datum (in AcOPMVariant) contains the actual  value as 'short'
  the second 16 bit part of the INT64 datum (in AcOPMVariant) contains the minimum value as 'short'
  the third  16 bit part of the INT64 datum (in AcOPMVariant) contains the maximum value as 'short'

  this means, all the minimum/maximum/current values must be in signed short range;
  the sample application also shows such usage with an 'opmTypeRange' property


'opmTypePatternType'
'opmTypePatternName'

  as pattern name and pattern type are always combined (can not be specified independently),
  both need to be combined into a single string for the get/setPropertyValue() function :
  the pattern type is used as a prefix to the pattern name, as follows :
  using "U|" for userdefined, "P|" for predefined, "C|" for custon pattern type


'opmTypeCombo'

  this is a special version of the dropdown/combobox property type, with edit field enabled
  in the dropdown/combobox control, so the user can enter arbitrary strings, not (yet) contained
  in the dropdown/combobox list;
  when user presses <enter>/<return> or removes the focus from the edit field, the
  AcOPMExtensionManager calls the "setPropertyValue()" function with the new value;
  at this point, the client extension can decide whether this is a valid value - in this case,
  the entered value should be added to the 'predefinedStrings' list, as the AcOPMExtensionManager
  queries for the actual 'predefinedStrings' list and the actual value by "getPropertyValue()"
  after successfully calling "setPropertyValue()" :
  at "getPredefinedStrings()", the newly entered string (if valid and appropriate) should be
  present in the 'predefinedStrings' returned to AcOPMExtensionManager;
  otherwise, the newly entered string is discarded;

  the sample application also shows such usage with an 'opmTypeCombo' property


'opmTypeCallback'

  the callback property always uses a string (wrapped in AcOPMVariant) to transfer data;
  when the user clicks into the property, a "browse" button (with label "...") is shown,
  and once clicked, the client callback function of type

    bool (*AcOPMPropertyDialogProc)(const AcDbObjectIdArray& pickSet,
                                    AcOPMPropertyId propertyId, const AcString& propertyName,
                                    const AcString& childName, AcOPMVariant& value)
  is called;
  other than for other property types, the callback function receives the list of related
  entities (as the behaviour of the callback handler might depend on this), and both
  the property ID and Name, for safe identification;
  if the client-side edit operation (commandline, dialog, etc.) succeeds, the result string
  should be placed into 'value', and the handler function should return 'true';
  otherwise, the edit operation is discarded;
  a new cycle with "getProeprtyValue()" is always done after callback operation


Hints for using the "No Selection" properties page :
----------------------------------------------------

For properties displayed on the "No Selection" OPM page, there is no automatic or cyclic refresh
of the properties, as those are normally triggered by changed to the actual drawing database.

This means, that there is no automatic update for client properties, if those have changed - simply,
the OPM never gets to know about such changes.

To solve this conflict, the AcOPMExtensionManager can be triggered to run an update cycle by
calling AcOPMExtensionManager's "updateNoSelectionProperties()" function, i.e. by using the macro
acOPMupdateNoSelectionProperties().
